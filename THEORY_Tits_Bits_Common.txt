- opacity ==============
    - 2 types
    - parent element bg(div) => child element gets also
    - only child element => only color opacity

- synchronus vs asynchronous

***
- // EXPLAIN LATER with DRAG and DROP, File Reader
    - events bubbling, delegetion CLASS mengtioned
***

- prototype-chaining ========
- syntatic sugar ====
- auto semicolon in VS code: ===
    alt + shift + f

- Array.from() ===
- eg. Array.from(element.children)
    is a safe, clean way to turn ‚Äúarray-like‚Äù or iterable things into a real Array 
    ‚Äî so you can use array methods like map, filter, reduce, etc.

    - The problem it solves:
        Some JS things look like arrays but aren‚Äôt arrays:

        1. NodeList ‚Üí from querySelectorAll
        2. HTMLCollection ‚Üí from .children
        3. arguments
        4. Strings
        5. Sets / Maps
    - Array.from() is a static method of the "Array constructor", 
      NOT a method on array instances.
    - If you call it on Array, it‚Äôs static.
      If you call it on [], it‚Äôs an instance method.
      Mental model üß†

    - Think of it like this:
        - Static method ‚Üí used to create arrays
        Array.from(), Array.isArray(), Array.of()

        - Instance method ‚Üí used to operate on arrays
        map(), push(), forEach()

- template
    - "JS DOM template" generally refers to using JavaScript to generate and insert HTML structures into the Document Object Model (DOM). 
   - JavaScript DOM templating, primarily using the <template> HTML element, serves to create reusable, inert HTML fragments that can be cloned and inserted into the live Document Object Model (DOM) dynamically at runtime using JavaScript. 
   - browser initially, acting as a blueprint until activated by script.
   - written in HTML (yet not visible without comment, without using css)
   = <template></template
   - Q: html tag written in html but will not be visible
    A: kept inside template tag

   - creates "document fragments"
   - reused by cloning 
   - content painting: to avoid, template is used in DOM
        - when update occurs in js, js startsover from 1st, rather than,
        - updatimg/patching the selected part.
        - to avoid it template is used
        - reload time lessens
        - dom loads initial 1 time, Loop runs multiple times

- dom range
    -  window.getSelection();
    - selecting dom element within a selected range

- js mutation observer
    - in infinity scroll
        - observes to how much product or info is loaded
        - like news feed
        - without clicking load more
        - 2 types:
        1. mutation observer: if any change in a DOM element; observes changes in DOM element. eg: how much vdo time watched
        2. iteration observer: if anything is iterarting: eg. scroll
        - developer built "transtack" which is package that handles these
- FFmpeg: video stream - support: high config tasks
    - streams in chunks, 
    - AI observes

- variable reassign vs declaration
    - Variable declaration
        Creating a variable for the first time
    - Variable reassignment
        Changing the value of an already declared variable.
        let x = 5;
        x = 20;      // reassignment
        No let / const / var

    - Only works if the variable is not const

- Multiple Promises ? before promise all 

- Promise
    - cannot be canceled
    - fetch can be aborted/cancelled
    - if no new promise is wanted to create & direct reolve/reject:
        Promise.resolve()
        Promise.reject()
    - promise in "loop" not recommended, as the serial of ids not maintained

- Promise.all()
// promise ref source: https://dev.to/shameel/javascript-promise-all-vs-allsettled-and-race-vs-any-3foj
    Promise.all method in JavaScript is used to handle multiple promises concurrently and wait for all of them to resolve.
    - form where one error rejects whole form

- Promise.allSettled()
    - uploading/ download files
- Difference between Promise.all() and Promise.allSettled()\

- Promise.race()
    - returns only 1 reject/ resolve whichever is done 1st
    - when settlement is important
    - like winning the race 1st

- Promise.any()
    - similar to race but returns 1 resolved
    - AggregateError: return Aggregated Error
    if all promises are rejected

- Use Cases:
    Promise.race: Useful when you want to implement scenarios like a timeout mechanism where you want to respond to the first promise to complete, regardless of whether it succeeds or fails.
    eg. database timeout

    Promise.any: Useful when you want to handle the case where at least one promise out of multiple promises succeeds, and you're interested in the result of the first resolving promise.

- async await:
- https://www.freecodecamp.org/news/javascript-async-await/
        - not better alternate of promise
        but syntatic sugar, code looks good,
        - increased readability
        - async/await syntax is a special syntax created to help you work with promise objects. It makes your code cleaner and clearer.
        - "await" keyword basically makes JavaScript wait until the Promise object is resolved or rejected. Instead of having to use the callback pattern inside the then() method, you can assign the fulfilled promise into a variable like this:
        - "await" keyword is placed before the call to a function or variable that returns a promise. It makes JavaScript wait for the promise object to settle before running the code in the next line.
        -


- fetch
    - a system to call URL  to get data
    - fetch = request 
       - request server to give something,
       - js has a "request-object" through which request is done to server for giving something.
       - server then sends a "promise" 
       - until it is received fully the promise is "pending"
       - if "promise" fails then it is rejected
       - if comes promise is "resolved"
       - fetch = keyword = function = by which "data" is taken from "URL"
- data collect from "URL":
    - by API calling "data" is collected from URL
    - when website is visited = URL is hit = data reaches from server to frontend based on that URL = these are basically API
        - eg. https://dummyjson.com/posts
            - "posts" = params = which part of the URL is needed

   - json data called to JS by keyword "fetch"
    - behind the secene uses "curl" to get data
    - curl https://json.....link :
        - shows/brings data
    - fetch works as wrapper for curl
        - "curl" has request power, who can request
    - eg.
        fetch('https://jsonplaceholder.typicode.com/todos/1')
        .then(response => response.json())
        .then(json => console.log(json))
        .catch(error => console.log(error));

        - response = mainly a "http response", for getting data 
            from it need to convert to JSON
        -   redirected: false, means the url didnt redirected to another url

- why for api calling async function is requred?
        - Asynchronous (async) functions are required for API calls to prevent the application or its user interface (UI) from freezing or becoming unresponsive while waiting for a response, which can take time due to network latency, server load, or other external factors. This non-blocking behavior is essential for a good user experience and application performance. 


- pagination :
    - backend system
    - skips and shows data to a certain limit
    - loads the next min limit if loaded
    - could be with page numbers
    - could be inifinity scrolls
        - eg. json of posts:
            {
                "posts": [],
                "total": 251,
                "skip": 0,
                "limit": 30
            }
    
 

- json
    - data format
    - is not directly readable
    - response = mainly a "http response", for getting data 
        from it need to convert to JSON

- async function
    - used in case of "await"
    - or it will give error
    - prettier
    - // these are syncronous, but does not block the main thread
        eg. :
    async function callApi(){
        const response = await fetch("https://jsonplaceholder.typicode.com/todos/1")
        const data = await response.json()
        console.log(data);
        
    }
    callApi()

    - try catch mandatory for error in async await
    - try ~ then
    - "finally" keyword : eg. after load database connection off , if want to add loader

    - async await & "iifee"
        - await is only valid in async functions and the top level bodies of modules
        // iffee is used for solve this error
        - / bcz the async function, returns "promise" for this promise has to "await" which is put inside "iifee" 
    - By using the async/await syntax, you reduce the need for method chaining and nested callbacks. This impact the readability of your code, especially when you have nested code like if/else and a for loop block
    - no race, no any, then combination of promise + async await

- Why Use the async/await Syntax?
    The async/await syntax enables you to handle promises without using .then() and .catch() method chaining, which also removes the need for nested callbacks.