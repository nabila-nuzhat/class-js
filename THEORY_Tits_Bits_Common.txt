- opacity ==============
    - 2 types
    - parent element bg(div) => child element gets also
    - only child element => only color opacity

- synchronus vs asynchronous

***
- // EXPLAIN LATER with DRAG and DROP, File Reader
    - events bubbling, delegetion CLASS mengtioned
***

- prototype-chaining ========
- syntatic sugar ====
- auto semicolon in VS code: ===
    alt + shift + f

- Array.from() ===
- eg. Array.from(element.children)
    is a safe, clean way to turn ‚Äúarray-like‚Äù or iterable things into a real Array 
    ‚Äî so you can use array methods like map, filter, reduce, etc.

    - The problem it solves:
        Some JS things look like arrays but aren‚Äôt arrays:

        1. NodeList ‚Üí from querySelectorAll
        2. HTMLCollection ‚Üí from .children
        3. arguments
        4. Strings
        5. Sets / Maps
    - Array.from() is a static method of the "Array constructor", 
      NOT a method on array instances.
    - If you call it on Array, it‚Äôs static.
      If you call it on [], it‚Äôs an instance method.
      Mental model üß†

    - Think of it like this:
        - Static method ‚Üí used to create arrays
        Array.from(), Array.isArray(), Array.of()

        - Instance method ‚Üí used to operate on arrays
        map(), push(), forEach()

- template
    - "JS DOM template" generally refers to using JavaScript to generate and insert HTML structures into the Document Object Model (DOM). 
   - JavaScript DOM templating, primarily using the <template> HTML element, serves to create reusable, inert HTML fragments that can be cloned and inserted into the live Document Object Model (DOM) dynamically at runtime using JavaScript. 
   - browser initially, acting as a blueprint until activated by script.
   - written in HTML (yet not visible without comment, without using css)
   = <template></template
   - Q: html tag written in html but will not be visible
    A: kept inside template tag

   - creates "document fragments"
   - reused by cloning 
   - content painting: to avoid, template is used in DOM
        - when update occurs in js, js startsover from 1st, rather than,
        - updatimg/patching the selected part.
        - to avoid it template is used
        - reload time lessens
        - dom loads initial 1 time, Loop runs multiple times

- dom range
    -  window.getSelection();
    - selecting dom element within a selected range

- js mutation observer
    - in infinity scroll
        - observes to how much product or info is loaded
        - like news feed
        - without clicking load more
        - 2 types:
        1. mutation observer: if any change in a DOM element; observes changes in DOM element. eg: how much vdo time watched
        2. iteration observer: if anything is iterarting: eg. scroll
        - developer built "transtack" which is package that handles these
- FFmpeg: video stream - support: high config tasks
    - streams in chunks, 
    - AI observes

- variable reassign vs declaration
    - Variable declaration
        Creating a variable for the first time
    - Variable reassignment
        Changing the value of an already declared variable.
        let x = 5;
        x = 20;      // reassignment
        No let / const / var

    - Only works if the variable is not const

- Multiple Promises ? before promise all 

- Promise
    - cannot be canceled
    - fetch can be aborted/cancelled
    - if no new promise is wanted to create & direct reolve/reject:
        Promise.resolve()
        Promise.reject()
    - promise in "loop" not recommended, as the serial of ids not maintained

- Promise.all()
// promise ref source: https://dev.to/shameel/javascript-promise-all-vs-allsettled-and-race-vs-any-3foj
    Promise.all method in JavaScript is used to handle multiple promises concurrently and wait for all of them to resolve.
    - form where one error rejects whole form

- Promise.allSettled()
    - uploading/ download files
- Difference between Promise.all() and Promise.allSettled()\

- Promise.race()
    - returns only 1 reject/ resolve whichever is done 1st
    - when settlement is important
    - like winning the race 1st

- Promise.any()
    - similar to race but returns 1 resolved
    - AggregateError: return Aggregated Error
    if all promises are rejected

- Use Cases:
    Promise.race: Useful when you want to implement scenarios like a timeout mechanism where you want to respond to the first promise to complete, regardless of whether it succeeds or fails.
    eg. database timeout

    Promise.any: Useful when you want to handle the case where at least one promise out of multiple promises succeeds, and you're interested in the result of the first resolving promise.

- async await:
- https://www.freecodecamp.org/news/javascript-async-await/
        - not better alternate of promise
        but syntatic sugar, code looks good,
        - increased readability
        - async/await syntax is a special syntax created to help you work with promise objects. It makes your code cleaner and clearer.
        - "await" keyword basically makes JavaScript wait until the Promise object is resolved or rejected. Instead of having to use the callback pattern inside the then() method, you can assign the fulfilled promise into a variable like this:
        - "await" keyword is placed before the call to a function or variable that returns a promise. It makes JavaScript wait for the promise object to settle before running the code in the next line.
        -


- fetch
    - a system to call URL  to get data
    - fetch = request 
       - request server to give something,
       - js has a "request-object" through which request is done to server for giving something.
       - server then sends a "promise" 
       - until it is received fully the promise is "pending"
       - if "promise" fails then it is rejected
       - if comes promise is "resolved"
       - fetch = keyword = function = by which "data" is taken from "URL"
- data collect from "URL":
    - by API calling "data" is collected from URL
    - when website is visited = URL is hit = data reaches from server to frontend based on that URL = these are basically API
        - eg. https://dummyjson.com/posts
            - "posts" = params = which part of the URL is needed

   - json data called to JS by keyword "fetch"
    - behind the secene uses "curl" to get data
    - curl https://json.....link :
        - shows/brings data
    - fetch works as wrapper for curl
        - "curl" has request power, who can request
    - eg.
        fetch('https://jsonplaceholder.typicode.com/todos/1')
        .then(response => response.json())
        .then(json => console.log(json))
        .catch(error => console.log(error));

        - response = mainly a "http response", for getting data 
            from it need to convert to JSON
        -   redirected: false, means the url didnt redirected to another url

- why for api calling async function is requred?
        - Asynchronous (async) functions are required for API calls to prevent the application or its user interface (UI) from freezing or becoming unresponsive while waiting for a response, which can take time due to network latency, server load, or other external factors. This non-blocking behavior is essential for a good user experience and application performance. 


- pagination :
    - backend system
    - skips and shows data to a certain limit
    - loads the next min limit if loaded
    - could be with page numbers
    - could be inifinity scrolls
        - eg. json of posts:
            {
                "posts": [],
                "total": 251,
                "skip": 0,
                "limit": 30
            }
    
 

- json
    - data format
    - is not directly readable
    - response = mainly a "http response", for getting data 
        from it need to convert to JSON

- async function
    - used in case of "await"
    - or it will give error
    - prettier
    - // these are syncronous, but does not block the main thread
        eg. :
    async function callApi(){
        const response = await fetch("https://jsonplaceholder.typicode.com/todos/1")
        const data = await response.json()
        console.log(data);
        
    }
    callApi()

    - try catch mandatory for error in async await
    - try ~ then
    - "finally" keyword : eg. after load database connection off , if want to add loader

    - async await & "iifee"
        - await is only valid in async functions and the top level bodies of modules
        // iffee is used for solve this error
        - / bcz the async function, returns "promise" for this promise has to "await" which is put inside "iifee" 
    - By using the async/await syntax, you reduce the need for method chaining and nested callbacks. This impact the readability of your code, especially when you have nested code like if/else and a for loop block
    - no race, no any, then combination of promise + async await

- Why Use the async/await Syntax?
    The async/await syntax enables you to handle promises without using .then() and .catch() method chaining, which also removes the need for nested callbacks.


- OOP :
https://www.freecodecamp.org/news/object-oriented-javascript-for-beginners/
https://www.freecodecamp.org/news/an-introduction-to-programming-paradigms/

    - "Objects" that are created from a "class" are called "instances".
    - core concept of OOP: is to "separate" "concerns into entities" "which are coded as objects".
    - Each entity will group a given set of information (properties) and actions (methods) that can be performed by the entity
    - OOP makes heavy usage of "classes" (which are a way of creating new objects starting out from a blueprint or boilerplate that the programmer sets).
    - programmatic way of creating objects and setting different properties and methods given a set of conditions. And that's what classes are good for.

    - "Classes" set a blueprint to create objects with predefined properties and methods. By creating a class, you can later on instantiate (create) objects from that "class", that will inherit all the properties and methods that "class" has.

- 4 key principles of OOP :
    - OOP is normally explained with "4 key principles" that dictate how OOP programs work/.
        inheritance
        encapsulation
        abstraction and 
        polymorphism

        - Inheritance : inheriting methods, properties from/of a class
            - is the ability to create classes based on other classes. With inheritance, we can define a parent class (with certain properties and methods), and then children classes that will inherit from the parent class all the properties and methods that it has.

            - eg. ATM: old common function: withdraw tk, new ATMs also added new features like CRM keeping the old withdraw finction.
                AC : heater, room temp show, auto etc

            - like new versions of apps inheriting core features.
            - inheritence is difficult in "functions"
                ‚ùå Functions do not directly support inheritance
                ‚úÖ Functions can implement inheritance using prototypes
                like,  Animal.prototype.speak = function () {
                            console.log("Animal speaks");
                                    };
                        Object.create(Animal.prototype);
                ‚úÖ Classes just make prototype inheritance easier and safer

            - repeating code is not optimal. A better way would be to declare a "parent-class" which is then extended by all other classes, like this:
eg.
class ClassParentName {
                constructor(ab) {
                this.ab = ab
    }

    method of parent-class = () => console.log(`I'm attacking with a power of ${this.power}!`)
}


class ChildClass extends ClassParentName {
    constructor (c, d, ab) {
        super(ab)
        this.prop1 = name
        this.prop2 = id
        this.prop3 = "pq"
    }

    method1 = () => console.log("Zzzzzziiiiiinnnnnggggg!!")
    method2 = () => console.log(this.d)
}

            - use the "constructor method" to "receive parameters" and assign them as properties, and methods are declared like simple functions

            - On the children class, we use the "extends" keyword to declare the parent class we want to inherit from.

            - Then in the constructor method, we have to declare the "parent-class's" parameter and use the "super function" to indicate that property is declared on the parent class.
                super(parameters)

            - wihtout iheriting the method can be newly created in another class as well with same name. bcz Even though the names are the same, they live in different ‚Äúcontainers‚Äù (prototypes). No conflict happens because JS looks inside the object‚Äôs own prototype chain for methods.(class record + chatgpt)

            - can't extend multiple classes, though there're are hacks and ways around this.

            - can't decide what to inherit from a parent class

            - Children classes can override the parent's properties and methods, by declaring it again,


        - Encapsulation : protecting properties
            -  it stands for an object's capacity to "decide" which information it exposes to "the outside" and which it doesn't. 
            
            - Encapsulation is implemented through "public and private properties" and methods.
            In JavaScript, all objects' properties and methods are public by default. "Public" just means we can access an object's property/method from outside its own body

            - first need to declare the "private property", always using the '#' symbol as the start of its name.

            - Then assign its value within the constructor function

            - Encapsulation is useful in cases where we need certain properties or methods for the inner working of the object, but we don't want to expose that to the exterior. Having private properties/methods ensures we don't "accidentally" expose information we don't want.

            - eg. hidden password

        - Getters and Setters: (in encapsulation)
        https://www.geeksforgeeks.org/javascript/javascript-getters-and-setters/
        https://www.w3schools.com/js/js_object_accessors.asp
            - These special methods provide controlled access to properties, allowing you to run validation logic before data is modified.
            - In JavaScript OOP, "getters and setters" are special methods
            - provide controlled access to an object's properties, enabling encapsulation, data validation, and computed properties.
            -   _name     //unserscore Conventionally private/protected property (older style)
            - getter and setter are the special methods introduced in ECMAScript 5 (ES5 2009) that allow us to retrieve and modify the values directly without directly changing the object property. The getter uses the get keyword and the setter uses the set keyword to modify and retrieve the values.


    - Abstraction : hiding complexity of a property, revealing the simple functional part only
            - Abstraction in JavaScript hides complex implementation details, 
            - exposing only essential features to manage code complexity.
            - allows developers to focus on what an object does rather than how it does it, commonly achieved through functions, closures, classes with private fields, and array methods.
            - reduce cognitive load. 
            - Abstraction is a principle that says that a class should only represent information that is relevant to the problem's context. In plain English, 
            - only expose to the outside the properties and methods that you're going to use. 
            - If it's not needed, don't expose it.

            - This principle is closely related to encapsulation, as we can use public and private properties/methods to decide what gets exposed and what doesn't.

            - show/reveal only that part, which is actually needed to use the functionality 
            - complexity hidden
            - eg. remote control's power on, volume change, etc
                ATM : card push, pass key -> cash out. the behind the scene is not visible outside
                coffee machine
            - eg. firebase: only provides backend service, but user do not have to code create anything.
            - eg. email validation function. user only will see email validated/not

            - Common Examples of Abstraction in JavaScript:
                - Function Abstraction: Creating a function like calculateTotal(price, tax) that encapsulates calculation logic, allowing the user to call it with inputs without knowing the mathematical formula.
                - Array Methods (map, filter, reduce): Using array.map() to transform data hides the underlying for loop, initialization, and array modification, providing a cleaner, declarative, and more abstract way to handle arrays.

                - Object Methods (OOP): A Car object with a .drive() method that starts the engine, locks doors, and checks fuel, while the user only sees a simple car.drive() command, hiding internal complexity.

                - Class Private Fields (#): Using private class fields (e.g., #calculateSalary) hides sensitive logic from external access, ensuring that only necessary public methods (e.g., getDetails()) are exposed.

                - Modules/API Interaction: Importing a function from a library (e.g., fetchData()) provides functionality without exposing the underlying API calls, headers, or error handling.
                - Event Listeners: Using element.addEventListener('click', handler) abstracts away the low-level browser mechanics of tracking mouse clicks and event propagation.
                - Component-Based Frameworks (e.g., React/Vue): Utilizing components <Button /> abstracts complex HTML, CSS, and behavior, allowing developers to use complex UI elements as simple building blocks.
                - Closures for Private Data: Using nested functions to keep variables private and hidden from the global scope, exposing only a public function to interact with them.

        - Simulating Abstract Classes:
                    - can mimic "Abstract Classes" by creating a base class & throwing error in methods that are intended to be abstract, 
                    - forcing derived classes to implement their own version
                    - if extended to subclass, the main class's method should be called in the subclass.
        - child class = drive class

            - Common Use Cases
                - API Development: Creating APIs where developers interact with a set of well-defined functions (endpoints) without needing to know the server-side logic or database interactions.
                - Built-in JavaScript Methods: Functions like Array.prototype.push() or Array.prototype.map() are perfect examples. You use them by name, but you don't know (or need to know) the complex internal algorithms that make them work.
                UI Components: When using a third-party library's UI component (e.g., a date picker), you use its provided properties (props) and methods, abstracting away the underlying HTML, CSS, and complex event handling.
                - Database Operations: Object-Relational Mapping (ORM) frameworks abstract raw SQL queries, allowing developers to interact with data using high-level JavaScript objects and methods.
                - Frameworks and Libraries: Modern web frameworks like React or Angular abstract much of the direct DOM manipulation, letting developers focus on the application's state and logic. 
        
        - Polymorphism: same method behiving differently in different cases
            - Polymorphism means "many forms".
            - It's the ability of "one method" to "return different values" according to certain conditions.

            - passing each class a different parameter at instantiation. That's one kind of polymorphism, "parameter-based"

            -  "inheritance-based" polymorphism, and that refers to when we have a parent class that sets a method and the child "overrides" that method to modify it in some way

            - ex: Polymorohism example added inside "oop-inheritance-ex3.js" example file

            - eg. Employee class: same function: "work" -> but same work function changes with designations of the Employees


    - Object Composition
        - Object composition is a "technique" that 
        - works as an "alternative to inheritance".
        - by using composition we can assign properties and methods to objects in a more flexible way than inheritance allows,
        -  objects get properties and methods assigned only as they need them
        - by using "functions" that receive the "object as a parameter"
        - assign the object from parameter the desired property/method
        - eg. car: motor, seat, battery, mirror, glass objects can be used individually too.
        - eg 2: ecommerce services: product, inventory, user login, order. not all features are used by all users. so all services are not in same place, rather built sepaerately and then connected.
        - compositing individual different objects to making another new thing. 
        - lessens hassle of "inheritance"
        - "micro service architecture" comes from this concept, to scale up, latency
        - eg. vs code extension

- oop composition vs inheritance:
    When to Use Which
        - Use Inheritance when:
        There is a clear, logical "is-a" hierarchy that adheres to the Liskov Substitution Principle (where a subclass can replace its superclass without issues).
        You need to reuse code from a base class and the relationship is stable and unlikely to change.
        Working with frameworks that require specific base classes to be extended (e.g., in GUI frameworks). 

        - Use Composition when:
        You need greater flexibility and the ability to change behavior at runtime.
        The relationship is a "has-a" or "uses a" relationship.
        You want to avoid complex class hierarchies and the problems of multiple inheritance.
        You want to promote loose coupling, making your code easier to test and maintain. 
        The principle of "favor composition over inheritance" is a best practice in OOP, advocating for composition as the default choice to create more robust, modular, and adaptable software systems. 
class: 
    - "Classes" set a blueprint to create objects with predefined properties and methods. By creating a class, you can later on instantiate (create) objects from that "class", that will inherit all the properties and methods that "class" has.

    - a class in a program is a definition of a ‚Äútype‚Äù of custom data structure that includes both data and behaviors that operate on that data. Classes define how such a data structure works,
    - classes are not themselves concrete values. To get a concrete value that you can use in the program, a class must be "instantiated" (with the "new" keyword) one or more times."

    - The class keyword creates a constant, so it cannot be redefined afterwards.

    - Classes are the blueprints or molds that we're going to use to create the actual objects.

    - Classes must always have a "constructor" method that will later on be used to instantiate that class.

    -  A "constructor" in JavaScript is just a plain old function that "returns an object". The only thing special about it is that, when invoked with the "new" keyword, it assigns its prototype as the prototype of the returned object.

    - "this" keyword points to the class itself (this refers to the object instance being created, not the class definition or ‚Äúclass itself.‚Äù) and is "used to define" the class properties within the constructor method. [clarification revised with the help of google and chatgpt. the confusion from concept source link is:https://www.freecodecamp.org/news/object-oriented-javascript-for-beginners/]

    - "Methods" can be added by simply defining the function name and its execution code.

    - JavaScript is a prototype-based language, and within JavaScript classes are used only as syntactic sugar. This doesn't make a huge difference here, but it's good to know and keep in mind.

    -"class-name" can start with small/capital letter but prefeable "capital-letter": convention

    - class syntax:
    class ClassName {
        constructor(parameters
         defining properties){
            methods(any function)/properties
            }
    }

    - "constructor-functions" can/may be converted to a class.
    - "constructor-functions" not common in other programming language for their developers. that's why "class" is introduced as "syntatic-sugar"

- constructor
     - A "constructor" in JavaScript is just a plain old function that "returns an object". 

    - The only thing special about it is that, when invoked with the "new" keyword, it assigns its prototype as the prototype of the returned object.

    - use the "constructor method" to "receive parameters" and assign them as properties, and methods are declared like simple functions

    - "constructor-functions" may be converted to a class
    - "constructor-functions" not common in other programming language for their developers. that's why "class" is introduced as "syntatic-sugar"



    - static method(js oop)
        - In JavaScript, a static method is a function that belongs to the class itself, rather than to any specific instance (object) of that class. You define them using the static keyword. 
        - Key Characteristics
        - Belongs to the class: Static methods are stored directly on the class's constructor function, not in its prototype.
        No instance needed: You call them using the class name directly (e.g., MyClass.myStaticMethod()), without first creating an instance with the new keyword.

        - No access to instance data: Inside a static method, the this keyword refers to the class (constructor) itself, not an object instance. This means they generally cannot access instance-specific properties or methods.
        
        - Use cases: They are commonly used for utility functions, helper methods, or factory methods that don't need access to an object's internal state. 
        Syntax and Example
        javascript
        class Calculator {
        // An instance method (needs an object instance to be called)
        addInstance(a, b) {
            return a + b;
        }

        // A static method (called on the class itself)
        static add(a, b) {
            return a + b;
        }
        }

        // Calling the static method:
        const sum = Calculator.add(5, 10);
        console.log(sum); // Output: 15

        // Trying to call the static method on an instance results in an error:
        const myCalc = new Calculator();
        // myCalc.add(5, 10); // Uncaught TypeError: myCalc.add is not a function

        // Calling the instance method:
        const instanceSum = myCalc.addInstance(2, 3);
        console.log(instanceSum); // Output: 5

        - Accessing Static Methods Internally
            You can call one static method from another static method (or a static initialization block) within the same class using the this keyword or the class name. 
        javascript
        class MyClass {
        static staticMethodOne() {
            return "Hello";
        }

        static staticMethodTwo() {
            // Calling another static method within the same class
            return MyClass.staticMethodOne() + " World!";
            // Alternatively, using this:
            // return this.staticMethodOne() + " World!";
        }
        }

        console.log(MyClass.staticMethodTwo()); // Output: Hello World!


- module
https://dev.to/rayan2228/javascript-module-system-explained-with-examples-3l6o
    - allows to split code into reusable files.
    - can coonect js files with each other by using -> export, import
        js files <script> tag with -> type = "module" attribute

    - ways of export/import:
        - named export/import
        - default export/import
        - namespace import (* as)
        - combined import (default + named)
If a module exports many values, you can import everything as an object.

        - named export:
            - Named exports allows to export multiple values/functions individually from a single file.
            - syntax: import {a, add, subtract } from "./module-1.js";
                export const a = 10;
                export const add = (a, b) => a + b;
                export const subtract = (a, b) => a - b;

        - default export
            - only 1 default export per module
            - 3 ways of default export
            - can be imported as different name than actual name used on the exported js file.
            eg. export const multiply = (a, b) => a * b;
                import { multiply as mul } from "./math.js";

        - Namespace Import (* as)
            - import all values from a target module
            - If a module exports many values, you can import everything as an object.
            -  namespace export object, does NOT include the default export.
            - namespace export object ONLY contains  named exports

        - Combined Import (Default + Named)
            - You can combine default and named imports in a single statement.
            - syntax: import getUser, { isAdmin } from "./user.js";
    